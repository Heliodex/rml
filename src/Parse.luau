local ChangeHistoryService = game:GetService "ChangeHistoryService"
local xml = require(script.Parent.xmlparser)
local xmlhandler = require(script.Parent.xmlparser.xmlhandler.dom)

return function(selected)
	-- Ensure the entire script is inside a comment
	local source = string.match(selected.Source, "^%s*%-%-%[%[(.*)%]%]%s*$")
		or selected.Source

	print "---------- Parsing rml... ----------"

	if not string.match(source, "^%s*<root>.+</root>%s*$") then
		-- XML parser only parses one element, so wrap everything in <root>
		source = `<root>{source}</root>`
	end

	ChangeHistoryService:SetWaypoint "Clear children of selection"

	local handler = xmlhandler:new()

	xml.parser(handler):parse(source)

	local scriptSource = ""

	local rootParent = game.StarterGui
	rootParent:ClearAllChildren()
	local referencedInstances = {}
	local connectedFunctions = {}

	local function children(e: table, parents: { Instance }, depth: number)
		for _, v in pairs(e) do
			if v._type == "ELEMENT" then
				print(string.rep("\t", depth), v._name)

				if v._name == "script" then
					for _, v2 in pairs(v._children) do
						if v2._type == "TEXT" then
							scriptSource ..= string.gsub(v2._text, "\n\t", "\n") .. "\n"
						end
					end

					continue
				end

				local instance = Instance.new(v._name)

				for i, a in v._attr or {} do
					print(string.rep("\t", depth), `{i}: {a}`)

					if i == "bind:this" then
						if referencedInstances[a] then
							warn(`Duplicate reference: {a}`)
						end
						referencedInstances[a] = instance
						continue
					elseif string.match(i, "^#") then
						local referenceName = string.match(i, "^#(%a%w*)$")
						if referencedInstances[referenceName] then
							warn(`Duplicate reference: {referenceName}`)
						end
						referencedInstances[referenceName] = instance
						continue
					elseif string.match(i, "^on:") then
						local eventName = string.match(i, "^on:(%a%w*)$")

						if not eventName then
							warn(`Invalid event name: {i}`)
							continue
						end

						if not connectedFunctions[a] then
							connectedFunctions[a] = {}
						end

						table.insert(
							connectedFunctions[a],
							{ instance = instance, eventName = eventName }
						)

						continue
					end

					if a == "" then
						a = true
					end

					if
						pcall(function()
							instance[i] = a
						end)
						or pcall(function()
							instance[i] = loadstring(`return {a}`)()
						end)
					then
						continue
					end

					warn(`Invalid attribute: {i} = {a}`)
				end

				table.insert(parents, instance)
				children(v._children, parents, depth + 1)
				table.remove(parents)

				instance.Parent = parents[#parents]
			elseif v._type == "TEXT" then
				local parent = parents[#parents]
				local text = string.gsub(v._text, "\n\t", "\n")

				if parent:IsA "TextLabel" or parent:IsA "TextButton" then
					parent.Text = text
				end
			end
		end
	end

	print "---------- Constructing instance tree... ----------"

	children(handler.root._children, { rootParent }, 1)

	if scriptSource == "" then
		return
	end

	print "---------- Writing scripts... ----------"

	local scriptPrepend =
		`-- This script was @generated by rml on {os.date "%c"}.\n`
	local scriptAppend = ""

	for i, v in pairs(referencedInstances) do
		local parentAccess = ""

		while v ~= rootParent do
			parentAccess = `["{v.Name}"]{parentAccess}`
			v = v.Parent
		end

		scriptPrepend ..= `local {i} = script.Parent{parentAccess}\n`
	end

	for func, v in pairs(connectedFunctions) do
		for _, v2 in pairs(v) do
			local parentAccess = ""

			while v2.instance ~= rootParent do
				parentAccess = `["{v2.instance.Name}"]{parentAccess}`
				v2.instance = v2.instance.Parent
			end

			scriptAppend ..= `script.Parent{parentAccess}.{v2.eventName}:Connect({func})\n`
		end
	end

	local src = `{scriptPrepend}\n{scriptSource}\n{scriptAppend}`
	local _, fn = pcall(loadstring, src)
	if not fn then
		warn "Script tag may have syntax errors"
	end

	local script = Instance.new "Script"
	script.RunContext = Enum.RunContext.Client
	script.Source = src
	script.Parent = rootParent
end
